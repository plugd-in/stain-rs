//! # `stain`
//!
//! A plugin system centered around traits, with support for
//! GATs and generics.
//!
//! Uses the [linkme] crate to "collect" implementations
//! at compile time. Aside from an internal [LazyLock] in front of
//! your implementation's constructor, this is a "zero-cost"
//! abstraction in the sense that there's no life-before main
//! concerns thanks to the linker doing the work for us.
//!
//! ## Usage
//!
//! You create a "stain" for your trait using [create_stain],
//! use the [stain] macro to "stain" your implementations
//! of that trait, then you "collect" the implementations using
//! a "store" generated by the [create_stain] macro.
//!
//! Here's an example of the general use of this crate:
//!
//! ```rust
//! use stain::{create_stain, stain, Store};
//!
//! pub trait Discover<T> {
//!     type Error;
//!
//!     fn discover(&self) -> Result<T, Self::Error>;
//! }
//!
//! create_stain! {
//!     trait Discover;
//!     ordering: u64;
//!
//!     type &'static str;
//!     trait type Error = &'static str;
//!
//!     prefix: stain_test;
//!     store: pub mod discover_store;
//! }
//!
//! // Stain registration uses [Default::default]
//! // to get the init value.
//! #[derive(Default)]
//! struct DiscoverLinux;
//!
//! impl Discover<&'static str> for DiscoverLinux {
//!     type Error = &'static str;
//!
//!     fn discover(&self) -> Result<&'static str, Self::Error> {
//!         Ok("Hello, Linux!")
//!     }
//! }
//!
//! stain! {
//!     store: discover_store;
//!     item: DiscoverLinux;
//!     ordering: 0; // See `Ordering` section for more.
//! }
//!
//! fn main() {
//!     let store = discover_store::Store::collect();
//!     let mut store_iter = store.iter();
//!
//!     let discover_linux = store_iter.next().expect("Discover Linux");
//!     assert_eq!(
//!         Ok("Hello, Linux!"),
//!         discover_linux.discover(),
//!     );
//!     assert_eq!("DiscoverLinux", discover_linux.name());
//! }
//! ```

use std::{
    any::{Any, TypeId},
    marker::PhantomData,
    ops::Deref,
    sync::{Arc, LazyLock},
};

#[doc(hidden)]
pub use itertools;
#[doc(hidden)]
pub use linkme;
#[doc(hidden)]
pub use paste::paste;

#[doc(hidden)]
mod macros;

/// A trait implemented by the storage structs generated by `create_stain!`.
///
/// This provides a uniform interface for collecting, iterating, and accessing
/// distributed plugin implementations.
pub trait Store: Sized {
    /// The dynamically dispatched trait type (e.g., `dyn Discover`).
    type Item: ?Sized + Send + Sync;

    /// The type used to sort the implementations (e.g., `u64`).
    type Ordering: Ord + Clone;

    /// Collects all distributed implementations linked into the binary.
    ///
    /// This operation allocates the internal storage and sorts the entries
    /// according to their defined ordering.
    ///
    /// # Example
    /// ```ignore
    /// let store = DiscoverStore::collect();
    /// ```
    fn collect() -> Self;

    /// Returns an iterator over all collected implementations, sorted by order.
    fn iter(&self) -> impl Iterator<Item = EntryRef<'_, Self::Ordering, Self::Item>>;

    /// Returns an iterator over implementations with a specific ordering value.
    fn ordering<'a>(
        &'a self,
        ordering: &Self::Ordering,
    ) -> Option<impl Iterator<Item = EntryRef<'a, Self::Ordering, Self::Item>> + 'a>;

    /// Retrieves a reference to a specific concrete implementation by its type.
    ///
    /// This allows you to "downcast" or find a specific plugin if you know its
    /// struct type at compile time.
    ///
    /// # Example
    /// ```ignore
    /// let linux_impl = store.concrete::<DiscoverLinux>();
    /// ```
    fn concrete<T: Any + Send + Sync>(&self) -> Option<ConcreteEntryRef<'_, T>>;
}

pub struct Entry<O, T: ?Sized> {
    type_id: TypeId,
    ordering: O,
    name: &'static str,
    inner: LazyLock<(Arc<T>, Arc<dyn Any + Send + Sync>)>,
}

pub struct ConcreteEntryRef<'e, C> {
    type_id: TypeId,
    name: &'static str,
    inner: Arc<C>,
    _phantom: PhantomData<&'e ()>,
}

impl<'e, C> ConcreteEntryRef<'e, C> {
    pub fn type_id(&self) -> TypeId {
        self.type_id
    }

    pub fn name(&self) -> &'static str {
        self.name
    }
}

impl<'e, C> Deref for ConcreteEntryRef<'e, C> {
    type Target = C;

    fn deref(&self) -> &Self::Target {
        self.inner.deref()
    }
}

pub struct EntryRef<'e, O, T>(&'e Entry<O, T>)
where
    T: ?Sized;

impl<'e, O, T> Deref for EntryRef<'e, O, T>
where
    T: ?Sized,
{
    type Target = Entry<O, T>;

    fn deref(&self) -> &'e Self::Target {
        &self.0
    }
}

impl<'e, O, T> From<&'e Entry<O, T>> for EntryRef<'e, O, T>
where
    T: ?Sized,
{
    fn from(value: &'e Entry<O, T>) -> Self {
        Self(value)
    }
}

impl<O, T> Eq for Entry<O, T>
where
    O: Eq,
    T: ?Sized,
{
}

impl<O, T> PartialEq for Entry<O, T>
where
    O: PartialEq,
    T: ?Sized,
{
    fn eq(&self, other: &Self) -> bool {
        self.ordering.eq(&other.ordering)
    }
}

impl<O, T> PartialOrd for Entry<O, T>
where
    O: PartialOrd,
    T: ?Sized,
{
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        self.ordering.partial_cmp(&other.ordering)
    }
}

impl<O, T> Ord for Entry<O, T>
where
    O: Ord,
    T: ?Sized,
{
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        self.ordering.cmp(&other.ordering)
    }
}

impl<O, T> Entry<O, T>
where
    T: ?Sized,
{
    pub fn type_id(&self) -> TypeId {
        self.type_id
    }

    pub fn ordering(&self) -> &O {
        &self.ordering
    }

    pub fn name(&self) -> &'static str {
        self.name
    }

    pub fn concrete<C>(&self) -> Option<ConcreteEntryRef<'_, C>>
    where
        C: Any + Send + Sync,
    {
        self.inner
            .1
            .clone()
            .downcast::<C>()
            .ok()
            .map(|concrete| ConcreteEntryRef {
                type_id: self.type_id,
                name: self.name,
                inner: concrete,
                _phantom: Default::default(),
            })
    }

    #[doc(hidden)]
    pub const fn new(
        type_id: TypeId,
        ordering: O,
        name: &'static str,
        init: fn() -> (Arc<T>, Arc<dyn Any + Send + Sync>),
    ) -> Self
    where
        O: Ord + Clone,
    {
        Self {
            inner: LazyLock::new(init),
            ordering,
            name,
            type_id,
        }
    }
}

impl<O, T> Deref for Entry<O, T>
where
    T: ?Sized,
{
    type Target = T;

    fn deref(&self) -> &Self::Target {
        self.inner.0.deref()
    }
}
